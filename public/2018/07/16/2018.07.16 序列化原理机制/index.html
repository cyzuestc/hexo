<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 序列化原理机制 · 陈昀钊</title><meta name="description" content="序列化原理机制 - 陈昀钊"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yzchen.com/atom.xml" title="陈昀钊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.uestc.edu.cn/" target="_blank" class="nav-list-link">UNIVERSITY</a></li><li class="nav-list-item"><a href="https://github.com/cyzuestc" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://bbs.uestc.edu.cn/" target="_blank" class="nav-list-link">清水河畔</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">序列化原理机制</h1><div class="post-info">Jul 16, 2018</div><div class="post-content"><h1 id="序列化是干什么的"><a href="#序列化是干什么的" class="headerlink" title="序列化是干什么的"></a>序列化是干什么的</h1><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保 存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br>类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。<br>序列化和反序列化的俩个主要类：ObjectOutputStream、ObjectInputStream。</p>
<h1 id="什么情况下需要序列化"><a href="#什么情况下需要序列化" class="headerlink" title="什么情况下需要序列化"></a>什么情况下需要序列化</h1><p>1.当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>2.当你想用套接字在网络上传送对象的时候；<br>3.当你想通过RMI传输对象的时候；</p>
<h1 id="当对一个对象实现序列化时，究竟发生了什么？"><a href="#当对一个对象实现序列化时，究竟发生了什么？" class="headerlink" title="当对一个对象实现序列化时，究竟发生了什么？"></a>当对一个对象实现序列化时，究竟发生了什么？</h1><p>在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Foo  myFoo = new Foo();     </span><br><span class="line">2. myFoo .setWidth(37);     </span><br><span class="line">3. myFoo.setHeight(70);</span><br></pre></td></tr></table></figure></p>
<p>当通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.dat文件中，这样以后又可以把它从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. FileOutputStream fs = new FileOutputStream(&quot;foo.dat&quot;);     </span><br><span class="line">2. ObjectOutputStream os = new ObjectOutputStream(fs);     </span><br><span class="line">3. os.writeObject(myFoo);</span><br></pre></td></tr></table></figure></p>
<h1 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h1><p>a）序列化时，只对对象的状态进行保存，而不管对象的方法；<br>b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；<br>c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；<br>d）并非所有的对象都可以序列化，至于为什么不可以，有很多原因了,比如：</p>
<p>1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。<br>2.资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。</p>
<h1 id="序列化算法一般做如下事情"><a href="#序列化算法一般做如下事情" class="headerlink" title="序列化算法一般做如下事情"></a>序列化算法一般做如下事情</h1><ol>
<li>将对象实例相关的类元数据输出.</li>
<li>递归地输出超类描述直到不再有超类.</li>
<li>类元数据完了以后,开始从最顶层的超类开始输出对象实例的实际数据值.</li>
<li>从上之下递归输出实例的数据.</li>
</ol>
<p></p><p>至此，Java序列化过程分析完毕，总结一下，在本例中序列化过程如下:</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-1752328/ep2pz45j79.png?imageView2/2/w/1620" style="cursor: zoom-in;" class=""><p></p>
</span></div></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/07/16/2018.07.16 synchronized原理/" class="prev">PREV</a><a href="/2018/07/16/2018.07.16 static与this/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 powered by <a href="https://github.com/cyzuestc" target="_blank">Chenyunzhao</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>