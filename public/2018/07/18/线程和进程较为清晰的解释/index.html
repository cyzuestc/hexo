<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 线程和进程较为清晰的解释 · 陈昀钊</title><meta name="description" content="线程和进程较为清晰的解释 - 陈昀钊"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yzchen.com/atom.xml" title="陈昀钊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">LASTEST</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ALL</a></li><li class="nav-list-item"><a href="https://www.uestc.edu.cn/" target="_blank" class="nav-list-link">UNIVERSITY</a></li><li class="nav-list-item"><a href="https://github.com/cyzuestc" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://bbs.uestc.edu.cn/" target="_blank" class="nav-list-link">BBS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">线程和进程较为清晰的解释</h1><div class="post-info">Jul 18, 2018</div><div class="post-content"><p><img src="https://img-blog.csdn.net/20180625012039828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE3NTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><br>线程是进程的一部分,每个操作系统可能同时有几百个进程在运行,每个进程有成百上千个线程在运行.<br><br>内存：逻辑内存，比如32位的系统有2的32次方，4G的寻址空间，则该系统的每个进程都有4G的内存空间可用，不一定都用。每个进程的内存都是互相独立的。<br><br>文件/网络句柄：是所有进程所共有的，比如说每个进程都可以打开同一个文件，同时去抢一个网络端口。<br><br><p><img src="https://img-blog.csdn.net/20180625012056601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE3NTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>

<p>栈：主线程的入口main函数不断进行函数调用，每次调用把参数和返回地址压到栈中去，每个函数的一些局部变量也会放到栈中。</p>
<p>PC：下一条执行指令的地址，操作系统运行的是线程，进程只是一个容器，指令本身放在内存中，每个线程都有PC指针指向自己那串代码的内存（计算机大多数是存储程序型的：数据和程序代码都在一片内存里）</p>
<p>TLS：存放一些线程独有的数据。</p>
<div class="htmledit_views"><br>                <p>进程：</p><p><img src="https://img-blog.csdn.net/20180625012039828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE3NTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>线程：是进程的一部分，每个操作系统可能同时有几十到几百个进程在运行，每个进程里有少到几个多到几十个甚至上百个线程在运行。</p><p>&nbsp;</p><p>内存：逻辑内存，比如32位的系统有2的32次方，4G的寻址空间，则该系统的每个进程都有4G的内存空间可用，不一定都用。每个进程的内存都是互相独立的。</p><p>&nbsp;</p><p>文件/网络句柄：是所有进程所共有的，比如说每个进程都可以打开同一个文件，同时去抢一个网络端口。</p><p>&nbsp;</p><p>线程：</p><p><img src="https://img-blog.csdn.net/20180625012056601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE3NTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>栈：主线程的入口main函数不断进行函数调用，每次调用把参数和返回地址压到栈中去，每个函数的一些局部变量也会放到栈中。</p><p>&nbsp;</p><p>PC：下一条执行指令的地址，操作系统运行的是线程，进程只是一个容器，指令本身放在内存中，每个线程都有PC指针指向自己那串代码的内存（计算机大多数是存储程序型的：数据和程序代码都在一片内存里）</p><p>所以漏洞——缓冲区溢出是指黑客把用户名输入得很长，跳出了给用户名分配的缓冲区，写到存取程序那一部分内存，通过这方法植入想要运行的代码。</p><p>防止方法：检测输入的用户名长度。</p><p>&nbsp;</p><p>TLS：存放一些线程独有的数据。</p><p>&nbsp;</p><p>所以进程和线程的一些区别有：</p><p>1、&nbsp; 进程因为不共享内存，所以交互比较麻烦，通过TCPIP端口实现交互是常用的方案（与系统相关性不大）</p><p>2、&nbsp; 线程通信比较简单，因为共享内存</p><p>3、&nbsp; 进程开销大，要分配内存</p><p>4、&nbsp; 线程开销小，只要分配栈和PC</p><p>&nbsp;</p><p>关于线程一些说法：</p><p>1、线程死程序的多个顺序的流动态执行。</p><p>2、线程没有自己独立的地址空间。</p><p>3、线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>            </div></div></article></div></main><footer><div class="paginator"><a href="/2018/07/18/解决hash碰撞冲突/" class="prev">PREV</a><a href="/2018/07/18/java类中serialversionuid作用是什么/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 powered by <a href="https://github.com/cyzuestc" target="_blank">Chenyunzhao</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>