<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 2017.10.27 Spring学习 · 陈昀钊</title><meta name="description" content="2017.10.27 Spring学习 - 陈昀钊"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yzchen.com/atom.xml" title="陈昀钊"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.uestc.edu.cn/" target="_blank" class="nav-list-link">UNIVERSITY</a></li><li class="nav-list-item"><a href="https://github.com/cyzuestc" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://bbs.uestc.edu.cn/" target="_blank" class="nav-list-link">清水河畔</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">2017.10.27 Spring学习</h1><div class="post-info">Oct 27, 2017</div><div class="post-content"><h2 id="1-Spring基本功能详解"><a href="#1-Spring基本功能详解" class="headerlink" title="1.Spring基本功能详解"></a>1.Spring基本功能详解</h2><ul>
<li><ol>
<li>SpringIOC<br>Spring的控制反转：把对象的创建、初始化、销毁等工作交给spring容器来做。由spring容器控制对象的生命周期。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A.	启动spring容器</span><br><span class="line">1、	在类路径下寻找配置文件来实例化容器 </span><br><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);可以在整个类路径中寻找xml文件</span><br><span class="line">* 通过这种方式加载。需要将spring的配置文件放到当前项目的classpath路径下</span><br><span class="line">*  classpath路径指的是当前项目的src目录，该目录是java源文件的存放位置。 </span><br><span class="line">2、	在文件系统路径下寻找配置文件来实例化容器 </span><br><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext(new String[]&#123;“d:\\beans.xml“&#125;);Spring的配置文件可以指定多个，可以通过String数组传入。</span><br><span class="line">注：经常用第一种方法启动容器</span><br><span class="line">B.	从spring容器中提取对象</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="2">
<li>别名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">	&lt;alias name=&quot;person&quot; alias=&quot;p&quot;/&gt;</span><br><span class="line">	&lt;bean name=&quot;person&quot; class=&quot;cn.itcast.aliasspring.Person&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">通过这样的配置，可以达到在一个地方命名，在多个地方使用不同的名字的效果。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>Spring容器内部对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-  1.创建对象的方式</span><br><span class="line">   -  无参构造函数</span><br><span class="line">   &lt;bean id=“personService&quot; class=&quot;cn.itcast.bean.impl.PersonServiceImpl&quot;/&gt;</span><br><span class="line">   -  静态工厂</span><br><span class="line">    &lt;bean id=&quot;personService&quot;  class=&quot;com.itcast.factory.PersonServiceFactory&quot;    factory-method=&quot;createPersonService&quot; /&gt;</span><br><span class="line">    public class PersonServiceFactory &#123;</span><br><span class="line">          public  static PersonService createPersonService()&#123;</span><br><span class="line">                return new PersonServiceImpl();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    -  实例工厂</span><br><span class="line">    记住概念即可</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="4">
<li>singleton(默认值) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在每个Spring IoC容器中一个bean定义只有一个对象实例(共享)。</span><br><span class="line">默认情况下会在容器启动时初始化bean，但我们可以指定Bean节点的lazy-init=“true”来延迟初始化bean，这时候，只有第一次获取bean会才初始化bean。如：</span><br><span class="line">&lt;beans default-lazy-init=&quot;true“ ...&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="5">
<li>prototype(原型；样机；典型)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">允许bean可以被多次实例化(使用一次就创建一个实例) . Spring不能对一个prototype bean的整个生命周期负责.这就意味着清楚prototype作用域的对象并释放任何prototype bean所持有的昂贵资源都是客户端的责任。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="6">
<li>Request<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一次http请求中,一个bean定义对应一个实例,即每次http请求将会有各自的bean实例, 他们依据某个bean定义创建而成.该作用域仅在基于web的Spring ApplicationContext情形下有效</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="7">
<li>Session<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一次http请求中,一个bean定义对应一个实例,该作用域仅在基于web的Spring ApplicationContext情形下有效</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="8">
<li>Global session<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Global session中,一个bean定义对应一个实例,仅在使用portlet context时有效.该作用域仅在基于web的Spring ApplicationContext情形下有效</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="9">
<li>初始化bean时机<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring默认在启动时将所有singleton bean提前进行实例化。提前实例化意味着作为初始化的一部分，ApplicationContext会自动创建并配置所有的singleton bean.通常情况下这是件好事。因为这样在配置中有任何错误能立即发现。</span><br><span class="line">Lazy-init=”true or  false”</span><br><span class="line">Lazy-init 为false,spring容器将在启动的时候报错（比较好的一种方式）</span><br><span class="line">Lazy-init 为true,spring容器将在调用该类的时候出错。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="10">
<li>init,destory<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法。</span><br><span class="line">   &lt;bean id=“foo” class=“...Foo”</span><br><span class="line">            init-method=“setup”</span><br><span class="line">            destory-method=“teardown”/&gt;</span><br><span class="line">当foo被载入到Spring容器中时调用init-method方法。当foo从容器中删除时调用destory-method（scope = singleton有效）</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="11">
<li>依赖注入(DI)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. 使用构造器注入</span><br><span class="line">    使用xml注入方式</span><br><span class="line">    A. 通过参数的顺序</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot;&gt;</span><br><span class="line">      &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot;&gt;</span><br><span class="line">           &lt;value&gt;56&lt;/value&gt;</span><br><span class="line">     &lt;/constructor-arg&gt; </span><br><span class="line">    B. 通过参数的类型</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">              &lt;value&gt;56&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">          &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">2. 使用属性setting方法进行注入</span><br><span class="line"></span><br><span class="line">    使用xml的注入方式：</span><br><span class="line">    </span><br><span class="line">    A.	简单Bean的注入</span><br><span class="line">    简单Bean包括两种类型：包装类型和String</span><br><span class="line">    &lt;bean id=&quot;personService&quot;   class=&quot;com.itcast.bean.impl.PersonServiceImpl&quot;&gt;</span><br><span class="line">    &lt;!-- 基本类型,string类型 --&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;张无忌&quot;&gt;&lt;/property&gt;                        &lt;/bean&gt;</span><br><span class="line">    B.	引用其他Bean</span><br><span class="line">    &lt;bean id=&quot;person&quot; class=&quot;com.itcast.bean.Person&quot; /&gt;</span><br><span class="line">     &lt;bean id=&quot;personService&quot;  class=&quot;com.itcast.bean.impl.PersonServiceImpl&quot;&gt;</span><br><span class="line">     &lt;property name=&quot;person&quot; ref=&quot;person&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    装配list集合</span><br><span class="line">    &lt;property name=&quot;lists&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;list1&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;list2&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;person&quot;&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    装配set集合</span><br><span class="line">    &lt;property name=&quot;sets&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;set1&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;set2&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;person&quot;&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    装配map集合</span><br><span class="line">    &lt;property name=&quot;maps&quot;&gt;</span><br><span class="line">             &lt;map&gt;</span><br><span class="line">                  &lt;entry key=&quot;01&quot;&gt;</span><br><span class="line">                          &lt;value&gt;map01&lt;/value&gt;</span><br><span class="line">                  &lt;/entry&gt;</span><br><span class="line">                  &lt;entry key=&quot;02&quot;&gt;</span><br><span class="line">                          &lt;value&gt;map02&lt;/value&gt;</span><br><span class="line">                  &lt;/entry&gt;	</span><br><span class="line">             &lt;/map&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/property&gt;       </span><br><span class="line">    map中的&lt;entry&gt;的数值和&lt;list&gt;以及&lt;set&gt;的一样，可以使任何有效的属性元素，需要注意的是key值必须是String的。</span><br><span class="line"></span><br><span class="line">    装配properties</span><br><span class="line">    &lt;property name=&quot;props&quot;&gt;</span><br><span class="line">           &lt;props&gt;</span><br><span class="line">             &lt;prop key=&quot;01&quot;&gt;prop1&lt;/prop&gt;</span><br><span class="line">             &lt;prop key=&quot;02&quot;&gt;prop2&lt;/prop&gt;</span><br><span class="line">           &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="12">
<li>注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">步骤：	</span><br><span class="line">A.	在配置文件中，引入context命名空间</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring- beans-2.5.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;</span><br><span class="line">B.	在配置文件中加入context:annotation-config标签</span><br><span class="line">&lt;context:annotation-config/&gt; </span><br><span class="line">这个配置隐式注册了多个对注释进行解析处理的处理器 </span><br><span class="line">AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor，</span><br><span class="line">PersistenceAnnotationBeanPostProcessor，RequiredAnnotationBeanPostProcessor </span><br><span class="line">注： @Resource注解在spring安装目录的lib\j2ee\common-annotations.jar</span><br><span class="line"></span><br><span class="line">1. @Autowired</span><br><span class="line">这两个注解的区别是：@Autowired 默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。 </span><br><span class="line">2. @Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</span><br><span class="line">3. @Qualifier</span><br><span class="line">如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：</span><br><span class="line">4. @Resource</span><br><span class="line">- 1、	@Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上.</span><br><span class="line">- 2、	@Resource注解默认按名称装配。</span><br><span class="line">        名称可以通过@Resource的name属性指定，如果没有指定name属性，</span><br><span class="line">        •	当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象</span><br><span class="line">        •	当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。 </span><br><span class="line">        •	注意：如果没有指定name属性，并且按照默认的名称找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。 </span><br><span class="line"></span><br><span class="line">5. @PostConstruct</span><br><span class="line">指定Bean的初始化方法</span><br><span class="line">6. @PreDestory</span><br><span class="line">指定Bean的销毁方法</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="13">
<li>扫描<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">前面的例子我们都是使用XML的bean定义来配置组件。在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找及维护起来也不太方便。spring2.5为我们引入了组件自动扫描机制，它可以在类路径底下寻找标注了@Component、@Service、@Controller、@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件是一样的。要使用自动扫描机制，我们需要打开以下配置信息:</span><br><span class="line">1、引入context命名空间  需要在xml配置文件中配置以下信息： </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">           http://www.springframework.org/schema/context</span><br><span class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;</span><br><span class="line">          &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">2、在配置文件中添加context:component-scan标签 </span><br><span class="line">       &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;</span><br><span class="line">       其中base-package为需要扫描的包(含子包)。</span><br><span class="line">注:</span><br><span class="line">1、在使用组件扫描元素时，AutowiredAnnotationBeanPostProcessor 和CommonAnnotationBeanPostProcessor会隐式地被包括进来。 也就是说，连个组件都会被自动检测并织入 - 所有这一切都不需要在XML中提供任何bean配置元数据。 </span><br><span class="line">2、功能介绍</span><br><span class="line">@Service用于标注业务层组件、</span><br><span class="line">@Controller用于标注控制层组件（如struts中的action）、</span><br><span class="line">@Repository用于标注数据访问组件，即DAO组件。</span><br><span class="line">而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ol start="14">
<li>Spring中的继承<br><code>`</code><bean id="student" class="cn..." parent="person">

</bean></li>
</ol>
<hr>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/28/2017.10.28 Spring学习/" class="prev">PREV</a><a href="/2017/10/23/2017.10.23 servlet/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 powered by <a href="https://github.com/cyzuestc" target="_blank">Chenyunzhao</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>